# 详细页架构设计（History + Detail）

本文档描述自检项目中设备 **详细页（Detail Page）** 的前端/中间层架构设计，用于支持：

* 最近 N 次自检记录的懒加载（History）
* 按选定记录加载详细自检结果（Detail）
* 支持不同设备类型（如：充电桩 Pile，换电站 Station，CCU 等）的扩展

为简化命名，文中类名使用：`HistoryModel`、`DetailModel`、`PileDetailModel` 等。

---

## 1. 整体目标

在设备详细页面中实现：

1. **历史记录列表（History）**

   * 进入详细页时，默认加载指定设备最近 10 次自检记录。
   * 只拉取“头部信息”（时间、状态、简要摘要等），体量小、可快速展示。
   * 支持后续扩展为：分页加载、按时间筛选、加载更多等。

2. **详细记录（Detail）**

   * 用户在历史列表中选择某一条记录时，再按记录唯一标识（推荐 `recordId`）去懒加载详细内容。
   * 详细内容可能包括多个子模块的状态、错误码、原始 JSON 等。

3. **通用模式**

   * 对于不同设备类型：Pile、Station、CCU 等，复用同一套 `HistoryModel + DetailModel` 模式，只扩展不同的 DetailModel 子类（如 `PileDetailModel`）。

---

## 2. 数据流与交互流程

### 2.1 典型页面结构

以某个“充电桩详细页”为例：

* 顶部展示设备基本信息（设备名称 / 编号 / 在线状态等）。
* 左侧或上部：自检历史记录列表（ListView + HistoryModel）。
* 右侧或下部：某一次自检的详细内容（Detail 区域 + PileDetailModel）。

### 2.2 交互流程

1. 用户从设备列表页进入某个设备的详细页：

   * QML 将设备编号 `deviceId` 传入详细页组件。
   * 详细页在 `Component.onCompleted` 中调用：

     * `historyModel.load(deviceId, 10)` → 拉取最近 10 条记录头部信息。

2. `HistoryModel` 完成加载后：

   * 列表显示每一条记录的时间、状态、摘要等。
   * 用户可以直接看到最近几次自检的大概情况。

3. 用户点击某条历史记录：

   * 通过 `HistoryModel.get(index)` 拿到该条记录的 `recordId` / `deviceId` / `timestamp`。
   * 调用 `detailModel.loadByRecordId(recordId)` 或 `detailModel.load(deviceId, timestamp)`。
   * `DetailModel` 后台懒加载该条记录的详细内容，加载完成后通过属性变更信号刷新详细区域 UI。

4. 后续扩展：

   * 支持“加载更多历史记录”：

     * `historyModel.loadMore(deviceId, offset, limit)` 或内部记录 lastId / lastTimestamp 进行翻页。
   * 支持按时间范围筛选：

     * `historyModel.load(deviceId, fromTime, toTime, limit)` 重载。

---

## 3. HistoryModel 设计

### 3.1 功能定位

`HistoryModel` 负责维护“某设备的自检历史记录列表”，仅保存**头部信息**：

* 记录唯一 ID：`recordId`（例如 MySQL 表的主键）。
* 设备编号：`deviceId`。
* 自检时间：`timestamp`。
* 状态：`status`（例如：`"normal" / "warning" / "error"`）。
* 简要摘要：`summary`（如：`"正常: 5, 异常: 1"`）。

该 Model 作为 QML ListView 的数据源，支持：

* 进入详细页时，加载最近 N 条记录。
* 提供 `get(row)` 方法，让 QML 在点击时可以拿到完整一条记录的信息。

### 3.2 C++ 接口概要

```cpp
class HistoryModel : public QAbstractListModel {
    Q_OBJECT
public:
    enum Roles {
        RecordIdRole = Qt::UserRole + 1,
        DeviceIdRole,
        TimestampRole,
        TimestampDisplayRole,
        StatusRole,
        SummaryRole
    };
    Q_ENUM(Roles)

    explicit HistoryModel(QObject* parent = nullptr);

    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role) const override;
    QHash<int, QByteArray> roleNames() const override;

    // QML 调用的加载接口：默认 limit = 10
    Q_INVOKABLE void load(const QString& deviceId, int limit = 10);

    // 提供一个 get(row) 方法，返回 QVariantMap 方便 QML 使用
    Q_INVOKABLE QVariant get(int row) const;

signals:
    void loadingChanged();
    void errorChanged(const QString& message);

private:
    struct Item {
        QString recordId;
        QString deviceId;
        QDateTime timestamp;
        QString status;
        QString summary;
    };

    std::vector<Item> items_;
    bool loading_ {false};

    void setLoading(bool v);
    void setItems(std::vector<Item>&& items);
};
```

### 3.3 数据来源和懒加载策略

* `load(deviceId, limit)` 只查询该设备最近 `limit` 条记录，按时间倒序排列。
* 查询由 Model 内部调用某个 service / repository（例如 `HistoryService`）完成，可使用 QtConcurrent 或自建线程避免阻塞 UI。
* Model 内部仅保存必要字段，**不保存完整 JSON 详情**，从而：

  * 内存占用更小。
  * 加载速度快，适合作为“轻量预览”。

---

## 4. DetailModel / PileDetailModel 设计

### 4.1 功能定位

`DetailModel` 表示“单条自检记录的完整详情”，针对不同设备类型可设计不同的子类，例如：

* `PileDetailModel`：充电桩自检详细信息。
* `StationDetailModel`：换电站自检详细信息。
* `CcuDetailModel`：CCU 自检详细信息。

共同特征：

* 提供一个或多个 `load*` 方法，用于按唯一标识（推荐 `recordId`）加载详情。
* 通过一组 Q_PROPERTY 暴露数据给 QML，包括：

  * 设备编号、时间戳、整体状态；
  * 各子模块的状态字段（可逐步扩展）；
  * 原始 JSON 文本（便于调试与通用展示）。

### 4.2 接口概要示例：PileDetailModel

```cpp
class PileDetailModel : public QObject {
    Q_OBJECT

    Q_PROPERTY(QString deviceId READ deviceId NOTIFY dataChanged)
    Q_PROPERTY(QDateTime timestamp READ timestamp NOTIFY dataChanged)
    Q_PROPERTY(QString status READ status NOTIFY dataChanged)
    Q_PROPERTY(QString rawJson READ rawJson NOTIFY dataChanged)
    // 后续可以继续拆分出更多字段：模块 A 状态、错误码等

public:
    explicit PileDetailModel(QObject* parent = nullptr);

    QString deviceId() const { return deviceId_; }
    QDateTime timestamp() const { return timestamp_; }
    QString status() const { return status_; }
    QString rawJson() const { return rawJson_; }

    // 推荐：使用 recordId 精确加载
    Q_INVOKABLE void loadByRecordId(const QString& recordId);

    // 备用方案：通过 deviceId + timestamp 查询
    Q_INVOKABLE void load(const QString& deviceId, const QDateTime& timestamp);

signals:
    void dataChanged();
    void loadingChanged();
    void errorChanged(const QString& message);

private:
    QString deviceId_;
    QDateTime timestamp_;
    QString status_;
    QString rawJson_;
    bool loading_ {false};

    void applyDataFromDb(/* DTO / struct */);
};
```

### 4.3 数据查询建议

后端数据库建议：

* 使用 `recordId`（自增 ID 或 UUID）作为主键，用于精确定位单条记录。
* 表结构中包含至少：`ID, DeviceId, CreatedAt, Status, DetailJson` 等字段。

典型查询语句：

* 按 `recordId` 查询：

  ```sql
  SELECT DeviceId, CreatedAt, Status, DetailJson
  FROM selfcheck_records
  WHERE ID = ?;
  ```

* 按 `deviceId + timestamp` 查询：

  ```sql
  SELECT DeviceId, CreatedAt, Status, DetailJson
  FROM selfcheck_records
  WHERE DeviceId = ? AND CreatedAt = ?
  LIMIT 1;
  ```

查询完成后，将字段映射到 `PileDetailModel` 内部属性，并发出 `dataChanged()` 信号通知 QML 刷新 UI。

---

## 5. QML 侧使用示例

以一个设备详细页 QML 结构为例，展示如何组合 `HistoryModel` 和 `PileDetailModel`：

```qml
// PileDetailPage.qml
import QtQuick 2.15
import QtQuick.Controls 2.15
import EAutoCheck 1.0   // C++ 中通过 qmlRegisterType 注册的模块

Item {
    id: root
    property string deviceId

    HistoryModel {
        id: historyModel
    }

    PileDetailModel {
        id: detailModel
    }

    Component.onCompleted: {
        if (deviceId.length > 0) {
            historyModel.load(deviceId, 10)
        }
    }

    ColumnLayout {
        anchors.fill: parent

        // 历史记录列表
        ListView {
            id: historyList
            Layout.fillWidth: true
            Layout.fillHeight: true
            model: historyModel

            delegate: ItemDelegate {
                width: ListView.view.width
                text: timestampDisplay + "  " + summary
                onClicked: {
                    const item = historyModel.get(index)
                    // 推荐用 recordId 精确加载
                    detailModel.loadByRecordId(item.recordId)
                }
            }
        }

        // 详情展示区域（示意）
        Rectangle {
            Layout.fillWidth: true
            Layout.preferredHeight: 220

            Column {
                anchors.fill: parent
                anchors.margins: 8

                Text { text: "设备: " + detailModel.deviceId }
                Text { text: "时间: " + detailModel.timestamp.toString("yyyy-MM-dd HH:mm:ss") }
                Text { text: "状态: " + detailModel.status }
                Text {
                    text: "原始 JSON: " + detailModel.rawJson
                    wrapMode: Text.Wrap
                }
            }
        }
    }
}
```

---

## 6. 懒加载策略与扩展点

### 6.1 懒加载策略总结

* **进入详细页时**：

  * 只加载历史头部信息（最近 N 条），由 `HistoryModel.load(deviceId, limit)` 完成。
  * 不自动加载任何单条记录详情。

* **用户点击历史记录时**：

  * 通过 `HistoryModel.get(index)` 拿到 `recordId` / `timestamp` 等。
  * 调用 `DetailModel.loadByRecordId(recordId)` 懒加载该条记录详情。

这样可以做到：

* 首屏快速可见（历史列表几乎立即出现）。
* 详细内容只在用户真正感兴趣时加载，节省资源。

### 6.2 可扩展点

1. **分页加载 / 加载更多**

   * 在 `HistoryModel` 中增加 `loadMore()` 或利用偏移量、最后一条记录 ID 实现翻页。

2. **筛选与排序**

   * 支持按时间范围、按状态（只看异常）等筛选条件。
   * 保持接口签名明确，或通过单独的 filter 对象配置。

3. **多设备类型复用**

   * `HistoryModel` 不依赖具体设备类型，只依赖设备 ID。
   * Detail 部分通过 `PileDetailModel`、`StationDetailModel` 等子类体现差异，只需要在 QML 中切换使用不同的 DetailModel 即可。

4. **缓存策略**

   * 可以在 service 层对近期访问的记录详情做简单缓存，减少重复数据库查询，尤其是在同一条记录被多次查看的场景下。

---

## 7. 小结

通过将详细页拆分为：

* 负责“记录头部列表”的 `HistoryModel`，
* 负责“单条记录完整详情”的 `DetailModel` / `PileDetailModel` 等，

可以实现：

* 首屏渲染快：进入详细页只加载少量数据。
* 访问效率高：详细内容按需懒加载，减轻后端压力。
* 结构清晰：History 与 Detail 职责单一，便于扩展不同设备类型与 UI 表现。

后续在实现时，只需按本设计补全 service/repository 访问 MySQL/Redis 的具体逻辑，并完善 QML 侧的 UI 组件即可。
